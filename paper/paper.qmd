<!-- Should be 20 to 25 pages, extensive citing (in every section) -->

# Introduction

## Motivation

In the era of cloud computing, outsourcing data storage has become a standard practice for individuals and organizations alike. It offers benefits such as scalability, cost-efficiency, and high availability. However, storing sensitive data on third-party servers raises significant privacy and security concerns. If the cloud provider is compromised or untrustworthy, sensitive information could be exposed.

To mitigate these risks, encryption is the standard defense. Encrypting data before uploading it ensures that the cloud provider, or any adversary who gains access to the storage, cannot read the plaintext information. However, standard encryption destroys the ability to efficiently search the data. Trivial solutions, such as downloading the entire dataset and decrypting it locally to perform a search, negate the benefits of cloud storage (scalability and bandwidth efficiency). This creates a fundamental tension between data security and data utility @Poh2017SearchableSE.

Searchable Symmetric Encryption (SSE) addresses this problem by allowing a client to store encrypted data on a server in such a way that the client can later execute search queries (e.g., keyword searches) and retrieve the matching documents without revealing the plaintext data or the query keywords to the server. This technology is crucial for enabling secure cloud storage services where privacy is paramount, such as in medical records systems, legal archives, and personal data backups @Bsch2014ASO.

## Problem Statement

The core problem addressed in this thesis is the design and implementation of a Searchable Symmetric Encryption (SSE) prototype that balances efficiency, functionality, and security. While basic SSE schemes for single-keyword search exist, real-world applications often require more complex query capabilities, such as boolean queries (conjunctive searches) and substring searches (finding patterns within words) @Faber2015RichQO.

Implementing these advanced features securely is non-trivial. It requires sophisticated cryptographic primitives and careful data structure design to minimize "leakage"-information that the server can infer about the data or queries from the access patterns. Furthermore, the implementation must be practical, scaling reasonably well with the size of the database. This project aims to demonstrate a functional SSE system in .NET that supports single-keyword, boolean, and substring queries, providing a tangible exploration of these theoretical concepts.

## Outline

This thesis is structured as follows:

- **Chapter 2 (Method)** lays the theoretical foundation, explaining the definitions of SSE, the security models, and the specific cryptographic constructions used for keyword, boolean, and substring search.
- **Chapter 3 (Implementation)** details the software architecture of the developed prototype, describing the project structure, key components, and providing code snippets to illustrate the core logic.
- **Chapter 4 (Users Guide)** provides a practical guide on how to install, configure, and use the Command Line Interface (CLI) application developed in this project.
- **Chapter 5 (Alternative Methods)** discusses other approaches to searching on encrypted data, such as Deterministic Encryption and Fully Homomorphic Encryption, comparing them to SSE.
- **Chapter 6 (Discussion)** concludes the thesis, summarizing the achievements, analyzing the limitations of the current prototype, and suggesting directions for future work.

# Method

## Theoretical Foundation

Searchable Symmetric Encryption (SSE) allows a client to encrypt a document collection $D$ and outsource it to an honest-but-curious server. The server should be able to identify documents matching a query $q$ generated by the client, without learning information about the plaintext $D$ or $q$, beyond well-defined leakage @Curtmola2006SearchableSE.

An SSE scheme generally consists of four algorithms: `KeyGen`, `BuildIndex`, `Trapdoor`, and `Search`.

1.  `KeyGen`: Generates a secret key $K$.
2.  `BuildIndex`: Takes the database $D$ and key $K$ to produce an encrypted index $I$ and a set of encrypted documents $C$.
3.  `Trapdoor`: Takes the key $K$ and a keyword $w$ to generate a search token $t_w$.
4.  `Search`: Takes the index $I$ and token $t_w$ to return the identifiers of documents containing $w$.

### Basic Keyword Search (Inverted Index)

The foundation of efficient SSE is the inverted index. In a plaintext inverted index, a dictionary maps each keyword to a list of document identifiers. In SSE, this structure is encrypted. The scheme implemented in this project follows the "SSE-1" construction by Curtmola et al. @Curtmola2006SearchableSE and the improvements by Cash et al. @Cash2013HighlyScalableSS.

Instead of mapping a keyword $w$ directly to a list, we generate a label for the list using a Pseudo-Random Function (PRF): $label = F_K(w)$. The list of document identifiers is encrypted. To hide the size of the lists and the access pattern to some extent, the identifiers are often encrypted individually and stored in a dictionary mapping random labels to encrypted identifiers.

### Boolean Queries (OXT Protocol)

For conjunctive queries (e.g., "search for documents containing $w_1$ AND $w_2$"), simply intersecting the result sets of two single-keyword searches leaks the document lists for both keywords individually. To avoid this, Cash et al. proposed the **Oblivious Cross-Tags (OXT)** protocol @Cash2013HighlyScalableSS.

OXT enables the server to compute the intersection without learning the document identifiers for the individual terms. It uses two structures:

1.  **TSet (Tuple Set):** A standard inverted index allowing the retrieval of encrypted document identifiers for the first keyword in the conjunction (the "pivot").
2.  **XSet (Cross-Tag Set):** A set of precomputed tags used to filter the results. For every document $d$ and keyword $w$, a tag is generated based on a blinded value of $w$ and a blinded value of $d$.

During a search for $w_1 \land w_2$, the client generates a token for $w_1$ to retrieve candidate documents from the TSet. For each candidate, the client provides a "cross-token" derived from $w_2$. The server combines the candidate document information with the cross-token to check if a corresponding element exists in the XSet. If it does, the document contains both $w_1$ and $w_2$.

### Substring Search

Substring search (finding "net" in "internet") is achieved by decomposing words into $q$-grams (substrings of length $q$). For example, "apple" with $q=3$ yields "app", "ppl", "ple". A naive approach is to index all $q$-grams. A search for a pattern is then a search for the conjunction of its constituent $q$-grams.

However, position matters. "act" and "cat" have the same letters but different meanings. To handle this, Faber et al. @Faber2015RichQO proposed including position information or adjacency information in the index. Our implementation uses a variation of this, indexing $q$-grams and "adjacency grams" (e.g., "app|ppl") to ensure the $q$-grams appear contiguously in the source text.

# Implementation

The prototype is implemented in **C#** using **.NET 8**, leveraging its strong typing and modern language features. The solution is organized into several projects to separate concerns: `SSE.Core`, `SSE.Client`, `SSE.Server`, `SSE.Cryptography`, and `SSE.CLI`.

## Project Structure

-   **SSE.Core**: Contains shared models (e.g., `Database`, `EncryptedDatabase`) and interfaces (`IIndex`).
-   **SSE.Cryptography**: Provides cryptographic primitives. It wraps .NET's `AES` and `HMACSHA256` and implements modular arithmetic using `System.Numerics.BigInteger` for the OXT protocol.
-   **SSE.Client**: Implements the logic for the SSE schemes. This is where the index construction (`Setup`) and query token generation (`Search`) happen.
-   **SSE.Server**: Simulates the cloud server. It holds the encrypted database and executes the search logic using tokens provided by the client.
-   **SSE.CLI**: A Text-based User Interface (TUI) for interacting with the system.

## Key Components

### Basic Scheme

The `BasicScheme` class implements the single-keyword search. The `Setup` method iterates through the keyword metadata. For each keyword, it derives two keys: a `labelKey` (to locate the list) and an `identifierKey` (to encrypt the document IDs).

```csharp
public static (byte[], EncryptedDatabase) Setup(Database<(string, string)> db)
{
    byte[] masterKey = CryptoUtils.GenerateRandomKey();
    var result = new List<(byte[] label, byte[] identifier)>();
    var metadata = db.GetMetadata();

    foreach (var keyword in metadata.Keys)
    {
        var labelKey = GetLabelKey(masterKey, keyword);
        var identifierKey = GetIdentifierKey(masterKey, keyword);
        // ... Encrypt identifiers and add to result ...
    }
    // ... Sort and build dictionary ...
}
```

### Boolean Query Scheme (OXT)

The `BooleanQueryScheme` is more complex. It implements the OXT protocol. The `Setup` phase builds the `TSet` (posting lists) and the `XSet` (membership tags).

The XSet tags are constructed using modular exponentiation in a prime group. The `BuildConjunctiveMembershipTag` method illustrates this:

```csharp
private BigInteger BuildConjunctiveMembershipTag(string keyword, BigInteger crossIdentifierExp)
{
    // ... Randomize keyword ...
    var exponent = CryptoUtils.ModMultiply(obscuredKeyword, crossIdentifierExp, ExponentGroupOrder);
    return BigInteger.ModPow(
        CryptoUtils.Generator(PrimeModulus),
        exponent,
        PrimeModulus
    );
}
```

This ensures that the server can verify membership only if it possesses the correct trapdoor information provided during the search protocol.

### Substring Query Scheme

The `SubstringQueryScheme` builds upon the `BooleanQueryScheme`. It preprocesses the text by extracting $q$-grams. It pads the text with boundary characters (e.g., `#`) to distinguish prefixes and suffixes.

```csharp
private static IEnumerable<string> ExtractFixedQGrams(string text, int q)
{
    if (string.IsNullOrEmpty(text) || text.Length < q) yield break;
    for (int i = 0; i + q <= text.Length; i++) 
        yield return text.Substring(i, q);
}
```

The search logic decomposes the query pattern into $q$-grams and executes a boolean AND query on the underlying OXT scheme.

# Users Guide

The prototype includes a Console-based application (`SSE.CLI`) that demonstrates the functionality of the implemented schemes.

## Getting Started

1.  **Prerequisites**: Ensure the .NET 8 SDK is installed.
2.  **Build**: Run `dotnet build` in the solution root.
3.  **Run**: Execute `dotnet run --project SSE.CLI`.

## Using the Interface

Upon launching, the main menu is displayed:

```text
================================================================================
 SSE Prototype - Select a Scheme
================================================================================
1. Basic Scheme (Cash et al. 2013)
2. Boolean Query Scheme (OXT - Cash et al. 2013)
3. Substring Query Scheme (Faber et al.)
4. Exit

Select an option:
```

### 1. Selecting a Scheme

Press `1`, `2`, or `3` to select the desired SSE scheme.

### 2. Loading Data

After selecting a scheme, you will be prompted to choose a data source:

-   **Use Sample Data**: Loads a small, hardcoded set of documents for quick testing.
-   **Load from Directory**: Allows you to specify an absolute path to a folder containing `.txt` files. Each file is treated as a document.

### 3. Performing Searches

Once the data is loaded and encrypted (Setup phase), you can perform searches.

-   **Basic Scheme**: Enter a single keyword (e.g., "encryption").
-   **Boolean Scheme**: Enter multiple keywords separated by spaces (e.g., "encryption security"). This will find documents containing *both* terms.
-   **Substring Scheme**: Enter a partial string (e.g., "crypt"). The system will find documents containing this fragment (e.g., "decryption", "cryptography").

# Experimental Results

<!-- results of the benchmarks, compare different schemes, evaluate how the different implementations index size scales also depending on the k-gram size -->

# Alternative Methods

While SSE is a powerful tool, it is not the only approach to searching on encrypted data. Here we verify 2-3 alternative methods.

## Deterministic Encryption (DTE)

Deterministic Encryption (DTE) is a scheme where encrypting the same plaintext $m$ with the same key $k$ always yields the same ciphertext $c$. This contrasts with probabilistic encryption (like AES-CBC with a random IV), where the ciphertext changes every time.

**Advantages:**

-   **Efficiency:** Search is extremely fast. To search for a keyword $w$, the client simply encrypts $w$ to get $c_w$ and the server performs a standard lookup for $c_w$ in the database.
-   **Simplicity:** It can be implemented using standard database technologies (e.g., SQL equality checks).

**Disadvantages:**

-   **Security:** DTE leaks the **frequency** of keywords (if "apple" appears 10 times, the same ciphertext appears 10 times) and the **repetition pattern**. This makes it vulnerable to frequency analysis attacks, especially on datasets with low entropy (e.g., gender, age) @Bsch2014ASO. It provides a much lower security guarantee than SSE.

## Fully Homomorphic Encryption (FHE)

Fully Homomorphic Encryption (FHE) allows arbitrary computations to be performed on ciphertext without decrypting it. If $Enc(x)$ is the encryption of $x$, FHE allows computing $Enc(f(x))$ given only $Enc(x)$ and the function $f$.

**Advantages:**

-   **Security:** It is the "holy grail" of cryptography. It leaks almost nothing to the server, as the server blindly computes functions without seeing data or access patterns.
-   **Flexibility:** It supports any type of query, not just search.

**Disadvantages:**

-   **Performance:** Despite recent advances, FHE remains computationally prohibitive for large-scale search operations. It is orders of magnitude slower than SSE @Poh2017SearchableSE. Searching a database essentially requires the server to "touch" every encrypted record to compute the result, preventing the use of efficient indices.

## Oblivious RAM (ORAM)

Oblivious RAM (ORAM) is a cryptographic primitive that hides the **access pattern** of a client accessing memory. Even if the data is encrypted, the sequence of memory addresses accessed can leak information. ORAM continuously shuffles and re-encrypts data as it is accessed to obfuscate these patterns.

**Advantages:**

-   **Access Pattern Security:** It provides stronger security than standard SSE by hiding which documents are being accessed.

**Disadvantages:**

-   **Overhead:** ORAM introduces significant bandwidth and computational overhead. Each logical read/write operation translates to multiple physical read/writes (often logarithmic or polylogarithmic in the dataset size). While more efficient than FHE, it is generally slower than optimized SSE schemes for simple search tasks @Curtmola2006SearchableSE.

# Discussion

## Conclusion

## Limitations

## Outlook

<!-- what could be added to the current implementation to make it better -->