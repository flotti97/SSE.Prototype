<!-- Should be 20 to 25 pages, extensive citing (in every section) -->

# Introduction

## Motivation

In the era of cloud computing, outsourcing data storage has become a standard practice for individuals and organizations alike. It offers benefits such as scalability, cost-efficiency, and high availability. However, storing sensitive data on third-party servers raises significant privacy and security concerns. If the cloud provider is compromised or untrustworthy, sensitive information could be exposed.

To mitigate these risks, encryption is the standard defense. Encrypting data before uploading it ensures that the cloud provider, or any adversary who gains access to the storage, cannot read the plaintext information. However, standard encryption destroys the ability to efficiently search the data. Trivial solutions, such as downloading the entire dataset and decrypting it locally to perform a search, negate the benefits of cloud storage (scalability and bandwidth efficiency). This creates a fundamental tension between data security and data utility @Poh2017SearchableSE.

Searchable Symmetric Encryption (SSE) addresses this problem by allowing a client to store encrypted data on a server in such a way that the client can later execute search queries (e.g., keyword searches) and retrieve the matching documents without revealing the plaintext data or the query keywords to the server. This technology is crucial for enabling secure cloud storage services where privacy is paramount, such as in medical records systems, legal archives, and personal data backups @Bsch2014ASO.

## Problem Statement

The core problem addressed in this thesis is the design and implementation of a Searchable Symmetric Encryption (SSE) prototype that balances efficiency, functionality, and security. While basic SSE schemes for single-keyword search exist, real-world applications often require more complex query capabilities, such as boolean queries (conjunctive searches) and substring searches (finding patterns within words) @Faber2015RichQO.

Implementing these advanced features securely is non-trivial. It requires sophisticated cryptographic primitives and careful data structure design to minimize "leakage"-information that the server can infer about the data or queries from the access patterns. Furthermore, the implementation must be practical, scaling reasonably well with the size of the database. This project aims to demonstrate a functional SSE system in .NET that supports single-keyword, boolean, and substring queries, providing a tangible exploration of these theoretical concepts.

## Outline

This thesis is structured as follows:

- **Chapter 2 (Method)** lays the theoretical foundation, explaining the definitions of SSE, the security models, and the specific cryptographic constructions used for keyword, boolean, and substring search.
- **Chapter 3 (Implementation)** details the software architecture of the developed prototype, describing the project structure, key components, and providing code snippets to illustrate the core logic.
- **Chapter 4 (Users Guide)** provides a practical guide on how to install, configure, and use the Command Line Interface (CLI) application developed in this project.
- **Chapter 5 (Alternative Methods)** discusses other approaches to searching on encrypted data, such as Deterministic Encryption and Fully Homomorphic Encryption, comparing them to SSE.
- **Chapter 6 (Discussion)** concludes the thesis, summarizing the achievements, analyzing the limitations of the current prototype, and suggesting directions for future work.

# Method

## Theoretical Foundation

Searchable Symmetric Encryption (SSE) allows a client to encrypt a document collection $D$ and outsource it to an honest-but-curious server. The server should be able to identify documents matching a query $q$ generated by the client, without learning information about the plaintext $D$ or $q$, beyond well-defined leakage @Curtmola2006SearchableSE.

An SSE scheme generally consists of four algorithms: `KeyGen`, `BuildIndex`, `Trapdoor`, and `Search`.

1.  `KeyGen`: Generates a secret key $K$.
2.  `BuildIndex`: Takes the database $D$ and key $K$ to produce an encrypted index $I$ and a set of encrypted documents $C$.
3.  `Trapdoor`: Takes the key $K$ and a keyword $w$ to generate a search token $t_w$.
4.  `Search`: Takes the index $I$ and token $t_w$ to return the identifiers of documents containing $w$.

### Basic Keyword Search (Inverted Index)

The foundation of efficient SSE is the inverted index. In a plaintext inverted index, a dictionary maps each keyword to a list of document identifiers. In SSE, this structure is encrypted. The scheme implemented in this project follows the "SSE-1" construction by Curtmola et al. @Curtmola2006SearchableSE and the improvements by Cash et al. @Cash2013HighlyScalableSS.

Instead of mapping a keyword $w$ directly to a list, we generate a label for the list using a Pseudo-Random Function (PRF): $label = F_K(w)$. The list of document identifiers is encrypted. To hide the size of the lists and the access pattern to some extent, the identifiers are often encrypted individually and stored in a dictionary mapping random labels to encrypted identifiers.

### Boolean Queries (OXT Protocol)

For conjunctive queries (e.g., "search for documents containing $w_1$ AND $w_2$"), simply intersecting the result sets of two single-keyword searches leaks the document lists for both keywords individually. To avoid this, Cash et al. proposed the **Oblivious Cross-Tags (OXT)** protocol @Cash2013HighlyScalableSS.

OXT enables the server to compute the intersection without learning the document identifiers for the individual terms. It uses two structures:

1.  **TSet (Tuple Set):** A standard inverted index allowing the retrieval of encrypted document identifiers for the first keyword in the conjunction (the "pivot").
2.  **XSet (Cross-Tag Set):** A set of precomputed tags used to filter the results. For every document $d$ and keyword $w$, a tag is generated based on a blinded value of $w$ and a blinded value of $d$.

During a search for $w_1 \land w_2$, the client generates a token for $w_1$ to retrieve candidate documents from the TSet. For each candidate, the client provides a "cross-token" derived from $w_2$. The server combines the candidate document information with the cross-token to check if a corresponding element exists in the XSet. If it does, the document contains both $w_1$ and $w_2$.

### Substring Search

Substring search (finding "net" in "internet") is achieved by decomposing words into $q$-grams (substrings of length $q$). For example, "apple" with $q=3$ yields "app", "ppl", "ple". A naive approach is to index all $q$-grams. A search for a pattern is then a search for the conjunction of its constituent $q$-grams.

However, position matters. "act" and "cat" have the same letters but different meanings. To handle this, Faber et al. @Faber2015RichQO proposed including position information or adjacency information in the index. Our implementation uses a variation of this, indexing $q$-grams and "adjacency grams" (e.g., "app|ppl") to ensure the $q$-grams appear contiguously in the source text.

# Implementation

<!-- project structure, explain key code components, include code snippets -->

# Users Guide

<!-- user guide for the tui -->

# Experimental Results

<!-- results of the benchmarks, compare different schemes, evaluate how the different implementations index size scales also depending on the k-gram size -->

# Alternative Methods

<!-- 2-3 alternative methods, 1 page per method -->

# Discussion

## Conclusion

## Limitations

## Outlook

<!-- what could be added to the current implementation to make it better -->